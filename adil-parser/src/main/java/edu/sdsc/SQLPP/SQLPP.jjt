options{
VISITOR=true;
MULTI=true;
STATIC = false;
}

PARSER_BEGIN(SQLPP)
package edu.sdsc.SQLPP;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonObjectBuilder;
import javax.json.JsonArrayBuilder;



import edu.sdsc.awesome.adil.parser.StatementOperation.SQLPPUtil;


public class SQLPP {
  public static void main(String[] args) {
    Reader sr = new StringReader(args[0]);
    JsonObjectBuilder js = Json.createObjectBuilder();
    SQLPP p = new SQLPP(sr);
    try {
      p.Expression(js);
    } catch (ParseException pe) {
      pe.printStackTrace();
    }
  }
}
PARSER_END(SQLPP)
SKIP : {
  " "
}


TOKEN [IGNORE_CASE]:
{
  <ALL : "all">
  | <AND : "and">
  | <ANY : "any">
  | <APPLY : "apply">
  | <AS : "as">
  | <ASC : "asc">
  | <AT : "at">
  | <AUTOGENERATED : "autogenerated">
  | <BETWEEN : "between">
  | <BTREE : "btree">
  | <BY : "by">
  | <CASE : "case">
  | <CLOSED : "closed">
  | <CREATE : "create">
  | <COMPACTION : "compaction">
  | <COMPACT : "compact">
  | <CONNECT : "connect">
  | <CORRELATE : "correlate">
  | <DATASET : "dataset">
  | <COLLECTION : "collection">
  | <DATAVERSE : "dataverse">
  | <DECLARE : "declare">
  | <DEFINITION : "definition">
  | <DELETE : "delete">
  | <DESC : "desc">
  | <DISCONNECT : "disconnect">
  | <DISTINCT : "distinct">
  | <DROP : "drop">
  | <ELEMENT : "element">
  | <EXPLAIN : "explain">
  | <ELSE : "else">
  | <ENFORCED : "enforced">
  | <END : "end">
  | <EVERY : "every">
  | <EXCEPT : "except">
  | <EXISTS : "exists">
  | <EXTERNAL : "external">
  | <FEED : "feed">
  | <FILTER : "filter">
  | <FLATTEN : "flatten">
  | <FOR : "for">
  | <FROM : "from">
  | <FULL : "full">
  | <FULLTEXT : "fulltext">
  | <FUNCTION : "Function">
  | <GROUP : "group">
  | <HAVING : "having">
  | <HINTS : "hints">
  | <IF : "if">
  | <INTO : "into">
  | <IN : "in">
  | <INDEX : "index">
  | <INGESTION : "ingestion">
  | <INNER : "inner">
  | <INSERT : "insert">
  | <INTERNAL : "internal">
  | <INTERSECT : "intersect">
  | <IS : "is">
  | <JOIN : "join">
  | <KEYWORD : "keyword">
  | <KEY : "key">
  | <LEFT : "left">
  | <LETTING : "letting">
  | <LET : "let">
  | <LIKE : "like">
  | <LIMIT : "limit">
  | <LOAD : "load">
  | <NODEGROUP : "nodegroup">
  | <NGRAM : "ngram">
  | <NOT : "not">
  | <OFFSET : "offset">
  | <ON : "on">
  | <OPEN : "open">
  | <OR : "or">
  | <ORDER : "order">
  | <OUTER : "outer">
  | <OUTPUT : "output">
  | <PATH : "path">
  | <POLICY : "policy">
  | <PRESORTED : "pre-sorted">
  | <PRIMARY : "primary">
  | <RAW : "raw">
  | <REFRESH : "refresh">
  | <RETURN : "return">
  | <RETURNING : "returning">
  | <RTREE : "rtree">
  | <RUN : "run">
  | <SATISFIES : "satisfies">
  | <SECONDARY : "secondary">
  | <SELECT : "select">
  | <SET : "set">
  | <SOME : "some">
  | <START : "start">
  | <STOP : "stop">
  | <TEMPORARY : "temporary">
  | <THEN : "then">
  | <TYPE : "type">
  | <TO : "to">
  | <UNION : "union">
  | <UNKNOWN : "unknown">
  | <UNNEST : "unnest">
  | <UPDATE : "update">
  | <UPSERT : "upsert">
  | <USE : "use">
  | <USING : "using">
  | <VALUE : "value">
  | <WHEN : "when">
  | <WHERE : "where">
  | <WITH : "with">
  | <WRITE : "write">
  | <COUNT : "count">
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <CARET : "^">
  | <CONCAT : "||">
  | <DIV : "/">
  | <IDIV : "idiv">
  | <MINUS : "-">
  | <MOD : "%">
  | <MUL : "*">
  | <PLUS : "+">

  | <LEFTPAREN : "(">
  | <RIGHTPAREN : ")">
  | <LEFTBRACKET : "[">
  | <RIGHTBRACKET : "]">

  | <ATT : "@">
  | <COLON : ":">
  | <COMMA : ",">
  | <DOT : ".">
  | <QUES : "?">
  | <SEMICOLON : ";">
  | <SHARP : "#">
  | <QUOT   : "\"">
  | <LT : "<">
  | <GT : ">">
  | <LE : "<=">
  | <GE : ">=">
  | <EQ : "=">
  | <NE : "!=">
  | <LG : "<>">
  | <SIMILAR : "~=">

}


<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <INTEGER_LITERAL : (<DIGIT>)+ >
}

<DEFAULT,IN_DBL_BRACE>
TOKEN [IGNORE_CASE]:
{
  <MISSING : "missing">
  |  <NULL : "null">
  | <TRUE : "true">
  | <FALSE : "false">
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <#DIGIT : ["0" - "9"]>
}

<DEFAULT,IN_DBL_BRACE>
TOKEN:
{
    < DOUBLE_LITERAL: <DIGITS> ( "." <DIGITS> ) (("e"|"E") ("-")? <DIGITS>)?
                      | <DIGITS> (("e"|"E") ("-")? <DIGITS>)
                      | "." <DIGITS> (("e"|"E") ("-")? <DIGITS>)?
    >
  | < FLOAT_LITERAL:  <DIGITS> ( "f" | "F" )
                      | <DIGITS> ( "." <DIGITS> ( "f" | "F" ) )?
                      | "." <DIGITS> ( "f" | "F" )
    >
  | <DIGITS : (<DIGIT>)+ >
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <#LETTER : ["A" - "Z", "a" - "z"]>
  | <SPECIALCHARS : ["$", "_"]>
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    // backslash u + 4 hex digits escapes are handled in the underlying JavaCharStream
    <QUOTED_STRING : "`" (
          <EscapeQuot>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["`","\\"])* "`">

  | < #EscapeQuot: "\\\"" >
  | < #EscapeApos: "\\\'" >
  | < #EscapeBslash: "\\\\" >
  | < #EscapeSlash: "\\/" >
  | < #EscapeBspace: "\\b" >
  | < #EscapeFormf: "\\f" >
  | < #EscapeNl: "\\n" >
  | < #EscapeCr: "\\r" >
  | < #EscapeTab: "\\t" >
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> | <SPECIALCHARS>)*>
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
  "\t"
  | "\r"
  | "\n"
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"//" (~["\n"])* "\n">
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"--" (~["\n"])* "\n">
}


<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
}



<INSIDE_COMMENT>
SPECIAL_TOKEN:
{
    <"+"(" ")*(~["*"])*>
}


TOKEN :
{

 < ALPHANUM : (<LETTER>|<DIGIT>)+>
 |<FIELDNAME : (<ALPHANUM>(<DOT><ALPHANUM>)*)>
 |<OPERATOR : <GT> | <LT> | <LE> | <GE> | (<EQ><EQ>) >



}





JsonObjectBuilder Expression(JsonObjectBuilder jObject) : {JsonArrayBuilder sqlPlan = Json.createArrayBuilder();} {

<QUOT> ({JsonObjectBuilder tempjObject = Json.createObjectBuilder();} tempjObject = Statement(tempjObject) {sqlPlan.add(tempjObject.build());} <SEMICOLON>)* <QUOT>

  {jObject.add("SQLPP", sqlPlan.build());}
  {return jObject; }
}

JsonObjectBuilder Statement(JsonObjectBuilder selectObject) : {JsonArrayBuilder tempArray = Json.createArrayBuilder();JsonObjectBuilder tempjObject = Json.createObjectBuilder();}
{
  ( LOOKAHEAD(1) (tempjObject = SelectStatement(tempjObject) {tempArray.add(tempjObject);}) | (tempjObject = SelectStatementWith(tempjObject) {tempArray.add(tempjObject);}) )

  {selectObject.add("STATEMENT", tempArray.build());}
  {return selectObject;}
}






JsonObjectBuilder SelectStatement(JsonObjectBuilder selectObject) : {Token aggrVar; boolean aggrFlag = false; Token groupName; Token limitValue; Token var; Token rename; Token srcName; Token srcrename;  boolean srcrenameFlag = false; Token groupBy = null; Token groupByRename = null; boolean groupByFlag=false;   List selectVar; JsonObjectBuilder renameTable = Json.createObjectBuilder(); selectVar = new ArrayList();
boolean selectRenameFlag = false; Token unnest; Token unnestRename = null; boolean unnestFlag = false; boolean exceptFlag = false; boolean limitFlag = false; Map valueObject = new HashMap(); Map groupByMap = new HashMap(); List groupList = new ArrayList(); boolean WHEREFlag = false; }

{
  <SELECT>
  ( LOOKAHEAD(1)(   ( ( LOOKAHEAD(1)(var = <IDENTIFIER>)| (var = <FIELDNAME>)|(var = <MUL> )))  ( <AS> (( LOOKAHEAD(1)(rename = <IDENTIFIER>)| (rename = <FIELDNAME>))){ renameTable.add(var.image, rename.image) ;}  {selectRenameFlag = true; })? { selectVar.add(var.image);} {valueObject.put("SelectVar", selectVar);}) | ({List count = new ArrayList(); }Aggregate(count) {valueObject.put("AGGRON", "SELECT");}{valueObject.put("AGGR", count); aggrFlag = true;}) )+

  (<FROM> ( ( LOOKAHEAD(1)(srcName = <IDENTIFIER>)| (srcName = <FIELDNAME>)) ) {valueObject.put("SRCNAME", srcName.image);}( ( LOOKAHEAD(1)(srcrename = <IDENTIFIER>)| (srcrename = <FIELDNAME>)) {srcrenameFlag = true;}{renameTable.add(srcName.image, srcrename.image);})? )

  (<UNNEST> unnest = <FIELDNAME> unnestRename = <IDENTIFIER> {unnestFlag = true; } {valueObject.put("UNNESTName", unnest.image);valueObject.put("UNNESTReName", unnestRename.image);}{ renameTable.add("UNNEST::"+unnest.image, unnestRename.image) ;})?
   (<GROUP> <BY> (groupBy = <FIELDNAME> (<AS> groupByRename = <IDENTIFIER> { groupByMap.put(groupByRename.image, groupBy) ;} { renameTable.add(groupBy.image, groupByRename.image) ;} )+
                                                                                    {groupByFlag = true;} { groupList.add(groupBy.image) ;})+
                                                                                    <GROUP> <AS> groupName = <IDENTIFIER>
                                                                                     {valueObject.put("groupName", groupName.image);}{valueObject.put("groupBy", groupList);valueObject.put("groupByRename", groupByRename.image);}  )?

                {JsonObjectBuilder j2 = Json.createObjectBuilder(); }(notINstatement(j2){exceptFlag = true;selectObject.add("NOTIN", j2.build());})?
                               (<IN> <LEFTPAREN> {JsonObjectBuilder j1 = SelectStatement(Json.createObjectBuilder()); selectObject.add("IN", j1); } {exceptFlag = true; } <RIGHTPAREN>)?

                               (  <WHERE> {JsonObjectBuilder j1 = Json.createObjectBuilder(); } j1 = GetConditionExpression(j1) {selectObject.add("CONDITION", j1); } {exceptFlag = true; }


                               )?


    (  <LIMIT> limitValue = <INTEGER_LITERAL> {limitFlag = true; }  {valueObject.put("limitValue", limitValue.image);} )?


    {selectObject = SQLPPUtil.handelSelectStatement(selectObject, srcName.image, srcrenameFlag, selectRenameFlag,  unnestFlag,  groupByFlag, exceptFlag,limitFlag, aggrFlag, valueObject );}
    {selectObject.add("AKA", renameTable.build());}

{return selectObject;}

}


 JsonObjectBuilder GetConditionExpression(JsonObjectBuilder l) : {Token t; List x; List y; Token o1; Token operand; Token o2; JsonArrayBuilder m  =Json.createArrayBuilder(); JsonObjectBuilder j1 = Json.createObjectBuilder(); JsonArrayBuilder p  =Json.createArrayBuilder(); JsonArrayBuilder k  =Json.createArrayBuilder(); }
{

        (( LOOKAHEAD(2)(o1 = <FIELDNAME>{ k.add(o1.image);})|( o1=<IDENTIFIER>{ k.add(o1.image);})|(o1 = <INTEGER_LITERAL>{ k.add(o1.image);}))    ( LOOKAHEAD(1) ( operand = <LT>{k.add(operand.image);}) | (<NOT> <IN>) )
        ( LOOKAHEAD(3)(notINstatement(j1) {k.add(j1.build());})|(o2 = <INTEGER_LITERAL>{k.add(o2.image);})|(o2 = <FIELDNAME>{k.add(o2.image);})
        | (o2=<IDENTIFIER>){k.add(o2.image);}){ m.add(k.build());})

      (<AND> ( LOOKAHEAD(2)(o1 = <FIELDNAME>)|( o1=<IDENTIFIER>)|
      (o1 = <INTEGER_LITERAL>) { p.add(o1.image);}) operand = <LT>{p.add(operand.image);} ( LOOKAHEAD(1)(notINstatement(j1){p.add(j1.build());})|
      (o2 = <INTEGER_LITERAL> {p.add(o2.image);})|(o2 = <FIELDNAME>{p.add(o2.image);})|
      (o2=<IDENTIFIER>{p.add(o2.image);})){ m.add(p.build()); })*{l.add("WHERE",m.build());}
{return l;}
}

JsonObjectBuilder notINstatement(JsonObjectBuilder j1) :{JsonObjectBuilder j2 = Json.createObjectBuilder();}
{
 <LEFTPAREN>  SelectStatement(j2) <RIGHTPAREN>

 {j1.add("NOTIN", j2.build());}
{return j1;}

}





void Aggregate(List count) : {Token t;}
{

(<COUNT><LEFTPAREN>t = <IDENTIFIER><RIGHTPAREN> {count.add(t.image);})
}

JsonObjectBuilder SelectStatementWith(JsonObjectBuilder selectObject) : {Token t; JsonObjectBuilder selectSTMT = Json.createObjectBuilder(); JsonObjectBuilder withSTMT = Json.createObjectBuilder();}
{
  <WITH> t = <IDENTIFIER> <AS> <LEFTPAREN> withSTMT = SelectStatement(withSTMT) <RIGHTPAREN> selectSTMT =  SelectStatement(selectSTMT)

  {selectObject.add("WITHSQLPP", selectSTMT.build());}
  {selectObject.add("WITHOOUTPUT", t.image);}
  {selectObject.add("WITHINSIDE", withSTMT.build());}


  {return selectObject;}

}



void Operator() : {} {
  Operand()
  "+" {System.out.println("Operator: " + tokenImage[PLUS]);}
  Operand()
}
void Operand() : {Token t;} {
  t=<INTEGER_LITERAL> {System.out.println("Operand: " + t.image);}
}
