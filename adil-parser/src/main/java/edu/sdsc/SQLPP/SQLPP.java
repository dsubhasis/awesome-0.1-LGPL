/*
 * Copyright (c) 2019.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 */

/* Generated By:JJTree&JavaCC: Do not edit this line. SQLPP.java */
package edu.sdsc.SQLPP;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonObjectBuilder;
import javax.json.JsonArrayBuilder;



import edu.sdsc.awesome.adil.parser.StatementOperation.SQLPPUtil;


public class SQLPP/*@bgen(jjtree)*/implements SQLPPTreeConstants, SQLPPConstants {/*@bgen(jjtree)*/
  protected JJTSQLPPState jjtree = new JJTSQLPPState();public static void main(String[] args) {
    Reader sr = new StringReader(args[0]);
    JsonObjectBuilder js = Json.createObjectBuilder();
    SQLPP p = new SQLPP(sr);
    try {
      p.Expression(js);
    } catch (ParseException pe) {
      pe.printStackTrace();
    }
  }

  final public JsonObjectBuilder Expression(JsonObjectBuilder jObject) throws ParseException {
                                                           /*@bgen(jjtree) Expression */
                                                           ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
                                                           boolean jjtc000 = true;
                                                           jjtree.openNodeScope(jjtn000);JsonArrayBuilder sqlPlan = Json.createArrayBuilder();
    try {
      jj_consume_token(QUOT);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SELECT:
        case WITH:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
         JsonObjectBuilder tempjObject = Json.createObjectBuilder();
        tempjObject = Statement(tempjObject);
                                                                                                            sqlPlan.add(tempjObject.build());
        jj_consume_token(SEMICOLON);
      }
      jj_consume_token(QUOT);
   jObject.add("SQLPP", sqlPlan.build());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jObject;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in Function");
  }

  final public JsonObjectBuilder Statement(JsonObjectBuilder selectObject) throws ParseException {
                                                               /*@bgen(jjtree) Statement */
                                                               ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
                                                               boolean jjtc000 = true;
                                                               jjtree.openNodeScope(jjtn000);JsonArrayBuilder tempArray = Json.createArrayBuilder();JsonObjectBuilder tempjObject = Json.createObjectBuilder();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SELECT:
        tempjObject = SelectStatement(tempjObject);
                                                              tempArray.add(tempjObject);
        break;
      case WITH:
        tempjObject = SelectStatementWith(tempjObject);
                                                                                                                                               tempArray.add(tempjObject);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   selectObject.add("STATEMENT", tempArray.build());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return selectObject;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in Function");
  }

  final public JsonObjectBuilder SelectStatement(JsonObjectBuilder selectObject) throws ParseException {
                                                                     /*@bgen(jjtree) SelectStatement */
                                                                     ASTSelectStatement jjtn000 = new ASTSelectStatement(JJTSELECTSTATEMENT);
                                                                     boolean jjtc000 = true;
                                                                     jjtree.openNodeScope(jjtn000);Token aggrVar; boolean aggrFlag = false; Token groupName; Token limitValue; Token var; Token rename; Token srcName; Token srcrename;  boolean srcrenameFlag = false; Token groupBy = null; Token groupByRename = null; boolean groupByFlag=false;   List selectVar; JsonObjectBuilder renameTable = Json.createObjectBuilder(); selectVar = new ArrayList();
boolean selectRenameFlag = false; Token unnest; Token unnestRename = null; boolean unnestFlag = false; boolean exceptFlag = false; boolean limitFlag = false; Map valueObject = new HashMap(); Map groupByMap = new HashMap(); List groupList = new ArrayList(); boolean WHEREFlag = false;
    try {
      jj_consume_token(SELECT);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MUL:
        case IDENTIFIER:
        case FIELDNAME:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            var = jj_consume_token(IDENTIFIER);
            break;
          case FIELDNAME:
            var = jj_consume_token(FIELDNAME);
            break;
          case MUL:
            var = jj_consume_token(MUL);
            break;
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AS:
            jj_consume_token(AS);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              rename = jj_consume_token(IDENTIFIER);
              break;
            case FIELDNAME:
              rename = jj_consume_token(FIELDNAME);
              break;
            default:
              jj_la1[3] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
                                                                                                                                                                         renameTable.add(var.image, rename.image) ;
                                                                                                                                                                                                                       selectRenameFlag = true;
            break;
          default:
            jj_la1[4] = jj_gen;
            ;
          }
                                                                                                                                                                                                                                                      selectVar.add(var.image);
                                                                                                                                                                                                                                                                                  valueObject.put("SelectVar", selectVar);
          break;
        case COUNT:
                                                                                                                                                                                                                                                                                                                                 List count = new ArrayList();
          Aggregate(count);
                                                                                                                                                                                                                                                                                                                                                                                  valueObject.put("AGGRON", "SELECT");
                                                                                                                                                                                                                                                                                                                                                                                                                        valueObject.put("AGGR", count); aggrFlag = true;
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COUNT:
        case MUL:
        case IDENTIFIER:
        case FIELDNAME:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_2;
        }
      }
      jj_consume_token(FROM);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        srcName = jj_consume_token(IDENTIFIER);
        break;
      case FIELDNAME:
        srcName = jj_consume_token(FIELDNAME);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                valueObject.put("SRCNAME", srcName.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case FIELDNAME:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          srcrename = jj_consume_token(IDENTIFIER);
          break;
        case FIELDNAME:
          srcrename = jj_consume_token(FIELDNAME);
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                                                                                                                                                                   srcrenameFlag = true;
                                                                                                                                                                                                                          renameTable.add(srcName.image, srcrename.image);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNNEST:
        jj_consume_token(UNNEST);
        unnest = jj_consume_token(FIELDNAME);
        unnestRename = jj_consume_token(IDENTIFIER);
                                                              unnestFlag = true;
                                                                                    valueObject.put("UNNESTName", unnest.image);valueObject.put("UNNESTReName", unnestRename.image);
                                                                                                                                                                                       renameTable.add("UNNEST::"+unnest.image, unnestRename.image) ;
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUP:
        jj_consume_token(GROUP);
        jj_consume_token(BY);
        label_3:
        while (true) {
          groupBy = jj_consume_token(FIELDNAME);
          label_4:
          while (true) {
            jj_consume_token(AS);
            groupByRename = jj_consume_token(IDENTIFIER);
                                                                             groupByMap.put(groupByRename.image, groupBy) ;
                                                                                                                               renameTable.add(groupBy.image, groupByRename.image) ;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case AS:
              ;
              break;
            default:
              jj_la1[11] = jj_gen;
              break label_4;
            }
          }
                                                                                     groupByFlag = true;
                                                                                                            groupList.add(groupBy.image) ;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FIELDNAME:
            ;
            break;
          default:
            jj_la1[12] = jj_gen;
            break label_3;
          }
        }
        jj_consume_token(GROUP);
        jj_consume_token(AS);
        groupName = jj_consume_token(IDENTIFIER);
                                                                                      valueObject.put("groupName", groupName.image);
                                                                                                                                      valueObject.put("groupBy", groupList);valueObject.put("groupByRename", groupByRename.image);
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
                 JsonObjectBuilder j2 = Json.createObjectBuilder();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN:
        notINstatement(j2);
                                                                                         exceptFlag = true;selectObject.add("NOTIN", j2.build());
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        jj_consume_token(IN);
        jj_consume_token(LEFTPAREN);
                                                  JsonObjectBuilder j1 = SelectStatement(Json.createObjectBuilder()); selectObject.add("IN", j1);
                                                                                                                                                     exceptFlag = true;
        jj_consume_token(RIGHTPAREN);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHERE:
        jj_consume_token(WHERE);
                                           JsonObjectBuilder j1 = Json.createObjectBuilder();
        j1 = GetConditionExpression(j1);
                                                                                                                                 selectObject.add("CONDITION", j1);
                                                                                                                                                                       exceptFlag = true;
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIMIT:
        jj_consume_token(LIMIT);
        limitValue = jj_consume_token(INTEGER_LITERAL);
                                               limitFlag = true;
                                                                     valueObject.put("limitValue", limitValue.image);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
     selectObject = SQLPPUtil.handelSelectStatement(selectObject, srcName.image, srcrenameFlag, selectRenameFlag,  unnestFlag,  groupByFlag, exceptFlag,limitFlag, aggrFlag, valueObject );
     selectObject.add("AKA", renameTable.build());
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
 {if (true) return selectObject;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in Function");
  }

  final public JsonObjectBuilder GetConditionExpression(JsonObjectBuilder l) throws ParseException {
                                                                  /*@bgen(jjtree) GetConditionExpression */
                                                                  ASTGetConditionExpression jjtn000 = new ASTGetConditionExpression(JJTGETCONDITIONEXPRESSION);
                                                                  boolean jjtc000 = true;
                                                                  jjtree.openNodeScope(jjtn000);Token t; List x; List y; Token o1; Token operand; Token o2; JsonArrayBuilder m  =Json.createArrayBuilder(); JsonObjectBuilder j1 = Json.createObjectBuilder(); JsonArrayBuilder p  =Json.createArrayBuilder(); JsonArrayBuilder k  =Json.createArrayBuilder();
    try {
      if (jj_2_1(2)) {
        o1 = jj_consume_token(FIELDNAME);
                                          k.add(o1.image);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          o1 = jj_consume_token(IDENTIFIER);
                                                                                k.add(o1.image);
          break;
        case INTEGER_LITERAL:
          o1 = jj_consume_token(INTEGER_LITERAL);
                                                                                                                            k.add(o1.image);
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        operand = jj_consume_token(LT);
                                                                                                                                                                                   k.add(operand.image);
        break;
      case NOT:
        jj_consume_token(NOT);
        jj_consume_token(IN);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_2(3)) {
        notINstatement(j1);
                                           k.add(j1.build());
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
          o2 = jj_consume_token(INTEGER_LITERAL);
                                                                                        k.add(o2.image);
          break;
        case FIELDNAME:
          o2 = jj_consume_token(FIELDNAME);
                                                                                                                             k.add(o2.image);
          break;
        case IDENTIFIER:
          o2 = jj_consume_token(IDENTIFIER);
                            k.add(o2.image);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                                                m.add(k.build());
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_5;
        }
        jj_consume_token(AND);
        if (jj_2_3(2)) {
          o1 = jj_consume_token(FIELDNAME);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            o1 = jj_consume_token(IDENTIFIER);
            break;
          case INTEGER_LITERAL:
            o1 = jj_consume_token(INTEGER_LITERAL);
                                 p.add(o1.image);
            break;
          default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        operand = jj_consume_token(LT);
                                                                   p.add(operand.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFTPAREN:
          notINstatement(j1);
                                                                                                                            p.add(j1.build());
          break;
        case INTEGER_LITERAL:
          o2 = jj_consume_token(INTEGER_LITERAL);
                               p.add(o2.image);
          break;
        case FIELDNAME:
          o2 = jj_consume_token(FIELDNAME);
                                                                    p.add(o2.image);
          break;
        case IDENTIFIER:
          o2 = jj_consume_token(IDENTIFIER);
                       p.add(o2.image);
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                            m.add(p.build());
      }
                                                                  l.add("WHERE",m.build());
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
 {if (true) return l;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in Function");
  }

  final public JsonObjectBuilder notINstatement(JsonObjectBuilder j1) throws ParseException {
                                                         /*@bgen(jjtree) notINstatement */
                                                         ASTnotINstatement jjtn000 = new ASTnotINstatement(JJTNOTINSTATEMENT);
                                                         boolean jjtc000 = true;
                                                         jjtree.openNodeScope(jjtn000);JsonObjectBuilder j2 = Json.createObjectBuilder();
    try {
      jj_consume_token(LEFTPAREN);
      SelectStatement(j2);
      jj_consume_token(RIGHTPAREN);
  j1.add("NOTIN", j2.build());
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
 {if (true) return j1;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in Function");
  }

  final public void Aggregate(List count) throws ParseException {
                              /*@bgen(jjtree) Aggregate */
                              ASTAggregate jjtn000 = new ASTAggregate(JJTAGGREGATE);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(COUNT);
      jj_consume_token(LEFTPAREN);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(RIGHTPAREN);
                                                  jjtree.closeNodeScope(jjtn000, true);
                                                  jjtc000 = false;
                                                 count.add(t.image);
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public JsonObjectBuilder SelectStatementWith(JsonObjectBuilder selectObject) throws ParseException {
                                                                         /*@bgen(jjtree) SelectStatementWith */
                                                                         ASTSelectStatementWith jjtn000 = new ASTSelectStatementWith(JJTSELECTSTATEMENTWITH);
                                                                         boolean jjtc000 = true;
                                                                         jjtree.openNodeScope(jjtn000);Token t; JsonObjectBuilder selectSTMT = Json.createObjectBuilder(); JsonObjectBuilder withSTMT = Json.createObjectBuilder();
    try {
      jj_consume_token(WITH);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(AS);
      jj_consume_token(LEFTPAREN);
      withSTMT = SelectStatement(withSTMT);
      jj_consume_token(RIGHTPAREN);
      selectSTMT = SelectStatement(selectSTMT);
   selectObject.add("WITHSQLPP", selectSTMT.build());
   selectObject.add("WITHOOUTPUT", t.image);
   selectObject.add("WITHINSIDE", withSTMT.build());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return selectObject;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in Function");
  }

  final public void Operator() throws ParseException {
                   /*@bgen(jjtree) Operator */
  ASTOperator jjtn000 = new ASTOperator(JJTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Operand();
      jj_consume_token(PLUS);
       System.out.println("Operator: " + tokenImage[PLUS]);
      Operand();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Operand() throws ParseException {
                  /*@bgen(jjtree) Operand */
                  ASTOperand jjtn000 = new ASTOperand(JJTOPERAND);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INTEGER_LITERAL);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       System.out.println("Operand: " + t.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_3R_11() {
    if (jj_scan_token(COUNT)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(FIELDNAME)) return true;
    return false;
  }

  private boolean jj_3R_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_9()) {
    jj_scanpos = xsp;
    if (jj_3R_10()) return true;
    }
    return false;
  }

  private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(162)) {
    jj_scanpos = xsp;
    if (jj_scan_token(172)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_7() {
    if (jj_scan_token(SELECT)) return true;
    Token xsp;
    if (jj_3R_8()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_8()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_6() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(FIELDNAME)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_6()) return true;
    return false;
  }

  private boolean jj_3R_10() {
    if (jj_3R_11()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SQLPPTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[24];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x80,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x4000,0x4000,0x800000,0x0,0x0,0x810000,0x810000,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x2000000,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x20,0x2000,0x0,0x2000,0x2000,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x1004,0x1004,0x0,0x1004,0x1004,0x1004,0x1004,0x1004,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x1004,0x0,0x4,0x1004,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[3];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SQLPP(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SQLPP(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SQLPPTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SQLPP(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SQLPPTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SQLPP(SQLPPTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SQLPPTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        exists = true;
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.add(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[174];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 24; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 174; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 3; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
