options{
VISITOR=true;
MULTI=true;
}

PARSER_BEGIN(SQLPP)
package edu.sdsc.SQLPP;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonObjectBuilder;



import edu.sdsc.awesome.adil.parser.StatementOperation.SQLPPUtil;


public class SQLPP {
  public static void main(String[] args) {
    Reader sr = new StringReader(args[0]);
    JsonObjectBuilder js = Json.createObjectBuilder();
    SQLPP p = new SQLPP(sr);
    try {
      p.Expression(js);
    } catch (ParseException pe) {
      pe.printStackTrace();
    }
  }
}
PARSER_END(SQLPP)
SKIP : {
  " "
}


TOKEN [IGNORE_CASE]:
{
  <ALL : "all">
  | <AND : "and">
  | <ANY : "any">
  | <APPLY : "apply">
  | <AS : "as">
  | <ASC : "asc">
  | <AT : "at">
  | <AUTOGENERATED : "autogenerated">
  | <BETWEEN : "between">
  | <BTREE : "btree">
  | <BY : "by">
  | <CASE : "case">
  | <CLOSED : "closed">
  | <CREATE : "create">
  | <COMPACTION : "compaction">
  | <COMPACT : "compact">
  | <CONNECT : "connect">
  | <CORRELATE : "correlate">
  | <DATASET : "dataset">
  | <COLLECTION : "collection">
  | <DATAVERSE : "dataverse">
  | <DECLARE : "declare">
  | <DEFINITION : "definition">
  | <DELETE : "delete">
  | <DESC : "desc">
  | <DISCONNECT : "disconnect">
  | <DISTINCT : "distinct">
  | <DROP : "drop">
  | <ELEMENT : "element">
  | <EXPLAIN : "explain">
  | <ELSE : "else">
  | <ENFORCED : "enforced">
  | <END : "end">
  | <EVERY : "every">
  | <EXCEPT : "except">
  | <EXISTS : "exists">
  | <EXTERNAL : "external">
  | <FEED : "feed">
  | <FILTER : "filter">
  | <FLATTEN : "flatten">
  | <FOR : "for">
  | <FROM : "from">
  | <FULL : "full">
  | <FULLTEXT : "fulltext">
  | <FUNCTION : "function">
  | <GROUP : "group">
  | <HAVING : "having">
  | <HINTS : "hints">
  | <IF : "if">
  | <INTO : "into">
  | <IN : "in">
  | <INDEX : "index">
  | <INGESTION : "ingestion">
  | <INNER : "inner">
  | <INSERT : "insert">
  | <INTERNAL : "internal">
  | <INTERSECT : "intersect">
  | <IS : "is">
  | <JOIN : "join">
  | <KEYWORD : "keyword">
  | <KEY : "key">
  | <LEFT : "left">
  | <LETTING : "letting">
  | <LET : "let">
  | <LIKE : "like">
  | <LIMIT : "limit">
  | <LOAD : "load">
  | <NODEGROUP : "nodegroup">
  | <NGRAM : "ngram">
  | <NOT : "not">
  | <OFFSET : "offset">
  | <ON : "on">
  | <OPEN : "open">
  | <OR : "or">
  | <ORDER : "order">
  | <OUTER : "outer">
  | <OUTPUT : "output">
  | <PATH : "path">
  | <POLICY : "policy">
  | <PRESORTED : "pre-sorted">
  | <PRIMARY : "primary">
  | <RAW : "raw">
  | <REFRESH : "refresh">
  | <RETURN : "return">
  | <RETURNING : "returning">
  | <RTREE : "rtree">
  | <RUN : "run">
  | <SATISFIES : "satisfies">
  | <SECONDARY : "secondary">
  | <SELECT : "select">
  | <SET : "set">
  | <SOME : "some">
  | <START : "start">
  | <STOP : "stop">
  | <TEMPORARY : "temporary">
  | <THEN : "then">
  | <TYPE : "type">
  | <TO : "to">
  | <UNION : "union">
  | <UNKNOWN : "unknown">
  | <UNNEST : "unnest">
  | <UPDATE : "update">
  | <UPSERT : "upsert">
  | <USE : "use">
  | <USING : "using">
  | <VALUE : "value">
  | <WHEN : "when">
  | <WHERE : "where">
  | <WITH : "with">
  | <WRITE : "write">
  | <COUNT : "count">
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <CARET : "^">
  | <CONCAT : "||">
  | <DIV : "/">
  | <IDIV : "idiv">
  | <MINUS : "-">
  | <MOD : "%">
  | <MUL : "*">
  | <PLUS : "+">

  | <LEFTPAREN : "(">
  | <RIGHTPAREN : ")">
  | <LEFTBRACKET : "[">
  | <RIGHTBRACKET : "]">

  | <ATT : "@">
  | <COLON : ":">
  | <COMMA : ",">
  | <DOT : ".">
  | <QUES : "?">
  | <SEMICOLON : ";">
  | <SHARP : "#">

  | <LT : "<">
  | <GT : ">">
  | <LE : "<=">
  | <GE : ">=">
  | <EQ : "=">
  | <NE : "!=">
  | <LG : "<>">
  | <SIMILAR : "~=">
}


<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <INTEGER_LITERAL : (<DIGIT>)+ >
}

<DEFAULT,IN_DBL_BRACE>
TOKEN [IGNORE_CASE]:
{
  <MISSING : "missing">
  |  <NULL : "null">
  | <TRUE : "true">
  | <FALSE : "false">
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <#DIGIT : ["0" - "9"]>
}

<DEFAULT,IN_DBL_BRACE>
TOKEN:
{
    < DOUBLE_LITERAL: <DIGITS> ( "." <DIGITS> ) (("e"|"E") ("-")? <DIGITS>)?
                      | <DIGITS> (("e"|"E") ("-")? <DIGITS>)
                      | "." <DIGITS> (("e"|"E") ("-")? <DIGITS>)?
    >
  | < FLOAT_LITERAL:  <DIGITS> ( "f" | "F" )
                      | <DIGITS> ( "." <DIGITS> ( "f" | "F" ) )?
                      | "." <DIGITS> ( "f" | "F" )
    >
  | <DIGITS : (<DIGIT>)+ >
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <#LETTER : ["A" - "Z", "a" - "z"]>
  | <SPECIALCHARS : ["$", "_"]>
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    // backslash u + 4 hex digits escapes are handled in the underlying JavaCharStream
    <QUOTED_STRING : "`" (
          <EscapeQuot>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["`","\\"])* "`">
  | <STRING_LITERAL : ("\"" (
          <EscapeQuot>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["\"","\\"])* "\"")
      | ("\'"(
          <EscapeApos>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["\'","\\"])* "\'")>
  | < #EscapeQuot: "\\\"" >
  | < #EscapeApos: "\\\'" >
  | < #EscapeBslash: "\\\\" >
  | < #EscapeSlash: "\\/" >
  | < #EscapeBspace: "\\b" >
  | < #EscapeFormf: "\\f" >
  | < #EscapeNl: "\\n" >
  | < #EscapeCr: "\\r" >
  | < #EscapeTab: "\\t" >
}

<DEFAULT,IN_DBL_BRACE>
TOKEN :
{
    <IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> | <SPECIALCHARS>)*>
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
  "\t"
  | "\r"
  | "\n"
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"//" (~["\n"])* "\n">
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
}

<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"--" (~["\n"])* "\n">
}


<DEFAULT,IN_DBL_BRACE>
SKIP:
{
    <"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
}



<INSIDE_COMMENT>
SPECIAL_TOKEN:
{
    <"+"(" ")*(~["*"])*>
}


TOKEN :
{

 < ALPHANUM : (<LETTER>|<DIGIT>)+>
 |<FIELDNAME : (<ALPHANUM>(<DOT><ALPHANUM>)*)>
 |< QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])+ "\"" | ("`" (~["\n","\r","`"])+ "`") | ( "[" ~["0"-"9","]"] (~["\n","\r","]"])* "]" ) >



}









JsonObjectBuilder Expression(JsonObjectBuilder selectObject) : {} {
  {return Statement(selectObject);}
}
JsonObjectBuilder Statement(JsonObjectBuilder selectObject) : {}
{
  selectObject = SelectStatement(selectObject) | selectObject = SelectStatementWith(selectObject)
  {return selectObject;}
}
JsonObjectBuilder SelectStatement(JsonObjectBuilder selectObject) : {Token aggrVar; boolean aggrFlag = false; Token groupName; Token limitValue; Token var; Token rename; Token srcName; Token srcrename;  boolean srcrenameFlag = false; Token groupBy = null; Token groupByRename = null; boolean groupByFlag=false;   List selectVar; Map selectMap = new HashMap(); selectVar = new ArrayList();
boolean selectRenameFlag = false; Token unnest; Token unnestRename = null; boolean unnestFlag = false; boolean exceptFlag = false; boolean limitFlag = false; Map valueObject = new HashMap(); Map groupByMap = new HashMap(); List groupList = new ArrayList(); }

{
  <SELECT>
  ( LOOKAHEAD(1)(var = <IDENTIFIER>  ( <AS> rename = <IDENTIFIER> { selectMap.put(rename.image, var) ;}  {selectRenameFlag = true; })? { selectVar.add(var.image);} {valueObject.put("SelectVar", selectVar); valueObject.put("SelectMap", selectMap);}) | {List count = new ArrayList(); }(Aggregate(count) {valueObject.put("AGGRON", "SELECT");}{valueObject.put("AGGR", count); aggrFlag = true;}) )+

  (<FROM> srcName = <IDENTIFIER> {valueObject.put("SRCRENAME", srcName);}(srcrename = <IDENTIFIER> {srcrenameFlag = true;}{valueObject.put("SRCRENAME", srcName);})? )

  (<UNNEST> unnest = <FIELDNAME> unnestRename = <IDENTIFIER> {unnestFlag = true; } {valueObject.put("UNNESTName", unnest);valueObject.put("UNNESTReName", unnestRename);})?
   (<GROUP> <BY> (groupBy = <FIELDNAME> (<AS> groupByRename = <IDENTIFIER> { groupByMap.put(groupByRename.image, groupBy) ;} )+ {groupByFlag = true;} { groupList.add(groupBy) ;})+ <GROUP> <AS> groupName = <IDENTIFIER> {valueObject.put("groupName", groupName.image);}{valueObject.put("groupBy", groupList);valueObject.put("groupByRename", groupByRename.image);})?

                               (<EXCEPT> {JsonObjectBuilder j1 = SelectStatement(Json.createObjectBuilder()); selectObject.add("EXCEPT", j1); } {exceptFlag = true; } )?
    (  <LIMIT> limitValue = <INTEGER_LITERAL> {limitFlag = true; } {valueObject.put("limitValue", limitValue.image);})?

    {selectObject = SQLPPUtil.handelSelectStatement(selectObject, srcName.image, srcrenameFlag, selectRenameFlag,  unnestFlag,  groupByFlag, exceptFlag,limitFlag, aggrFlag, valueObject );}

{return selectObject;}

}


void Aggregate(List count) : {Token t;}
{

(<COUNT><LEFTPAREN>t = <IDENTIFIER><RIGHTPAREN> {count.add(t.image);})
}

JsonObjectBuilder SelectStatementWith(JsonObjectBuilder selectObject) : {Token t;}
{
  <WITH> t = <IDENTIFIER> <AS> <LEFTPAREN> SelectStatement(selectObject) <RIGHTPAREN>

  {return selectObject;}

}



void Operator() : {} {
  Operand()
  "+" {System.out.println("Operator: " + tokenImage[PLUS]);}
  Operand()
}
void Operand() : {Token t;} {
  t=<INTEGER_LITERAL> {System.out.println("Operand: " + t.image);}
}
