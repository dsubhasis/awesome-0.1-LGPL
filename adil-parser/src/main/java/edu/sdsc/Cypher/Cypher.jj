/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Cypher.jj */
/*@egen*/options{

STATIC = false;
}

PARSER_BEGIN(Cypher)
package edu.sdsc.Cypher;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonObjectBuilder;
import javax.json.JsonArrayBuilder;


import static edu.sdsc.awesome.adil.parser.StatementOperation.CypherUtil.*;

public class Cypher/*@bgen(jjtree)*/implements CypherTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCypherState jjtree = new JJTCypherState();

/*@egen*/
  public static void main(String[] args) {
    Reader sr = new StringReader(args[0]);
    JsonObjectBuilder cypherNode = Json.createObjectBuilder();


    Cypher p = new Cypher(sr);
    try {
      p.Expression(cypherNode);
    } catch (ParseException pe) {
      pe.printStackTrace();
    }
  }
}

PARSER_END(Cypher)
SKIP : {
  " "
}


TOKEN [IGNORE_CASE]:
{
 < CREATE : "create">
 | < CONSTRAINT : "constraint" >
 | <ON : "on" >
 | < ASSERT : "assert" >
 | < UNIQUE : "unique" >
 | < MATCH : "match" >
 | <MERGE : "merge" >
 |<IS : "is" >

}

TOKEN :
{
    <CARET : "^">
  | <CONCAT : "||">
  | <DIV : "/">
  | <IDIV : "idiv">
  | <MINUS : "-">
  | <MOD : "%">
  | <MUL : "*">
  | <PLUS : "+">

  | <LEFTPAREN : "(">
  | <RIGHTPAREN : ")">
  | <LEFTBRACKET : "[">
  | <RIGHTBRACKET : "]">
  | <LEFTCURL : "{">
  | <RIGHTCURL : "}">
  | <QUOT : "\"">




  | <ATT : "@">
  | <COLON : ":">
  | <COMMA : ",">
  | <DOT : ".">
  | <QUES : "?">
  | <SEMICOLON : ";">
  | <SHARP : "#">

  | <LT : "<">
  | <GT : ">">
  | <LE : "<=">
  | <GE : ">=">
  | <EQ : "=">
  | <NE : "!=">
  | <LG : "<>">
  | <SIMILAR : "~=">
}

TOKEN [IGNORE_CASE]:
{
 < UNNEST : "unnest">
 | <SELECT : "select" >
 | <FROM : "from">
 | <AS : "as" >
 | <GROUP : "group" >
 | <BY : "by" >
 | <LIMIT : "limit">
 |<DIGITS : "digita" >


}

TOKEN :
{
   < #DIGIT    : ["0"-"9"] >
 | < #LETTER   : ["a"-"z","A"-"Z"] >
 | < ALPHANUM : (<LETTER>|<DIGIT>)+>
 | <FIELDNAME : (<ALPHANUM>(<DOT><ALPHANUM>)*)>
 | <CYPHERFIELD : (<ALPHANUM>(<COLON><ALPHANUM>)?)>



}


JsonObjectBuilder Expression(JsonObjectBuilder jObject) : {/*@bgen(jjtree) Expression */
                                                           SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
                                                           boolean jjtc000 = true;
                                                           jjtree.openNodeScope(jjtn000);
/*@egen*/JsonArrayBuilder cypherPlan = Json.createArrayBuilder();} {/*@bgen(jjtree) Expression */
try {
/*@egen*/

<QUOT> ({JsonObjectBuilder tempjObject = Json.createObjectBuilder();} tempjObject = Statement(tempjObject) {cypherPlan.add(tempjObject.build());} <SEMICOLON>)* <QUOT>

  {jObject.add("Cypher", cypherPlan.build());}/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jObject; }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

JsonObjectBuilder Statement(JsonObjectBuilder jObject) : {/*@bgen(jjtree) Statement */
                                                          SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
                                                          boolean jjtc000 = true;
                                                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token T; JsonArrayBuilder tempArray = Json.createArrayBuilder();JsonObjectBuilder tempjObject = Json.createObjectBuilder();}
{/*@bgen(jjtree) Statement */
try {
/*@egen*/

(LOOKAHEAD(1) (tempjObject = createStatement(tempjObject){tempArray.add(tempjObject);}) | (tempjObject =  MatchStatement(tempjObject){tempArray.add(tempjObject);}))

{jObject.add("STATEMENT", tempArray.build());}/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {return jObject;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/


}


 JsonObjectBuilder createStatement(JsonObjectBuilder jObject) : {/*@bgen(jjtree) createStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTCREATESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) createStatement */
 try {
/*@egen*/
 <CREATE> (LOOKAHEAD(1) jObject = createConstantStatement(jObject) | jObject = createEntryStatement(jObject))/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/

  {return jObject;}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

JsonObjectBuilder createConstantStatement(JsonObjectBuilder jObject) : {/*@bgen(jjtree) createConstantStatement */
                                                                        SimpleNode jjtn000 = new SimpleNode(JJTCREATECONSTANTSTATEMENT);
                                                                        boolean jjtc000 = true;
                                                                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; Token x; JsonObjectBuilder data = Json.createObjectBuilder();}
{/*@bgen(jjtree) createConstantStatement */
try {
/*@egen*/
( LOOKAHEAD(1)(<CONSTRAINT> <ON> <LEFTPAREN> x = <CYPHERFIELD> <RIGHTPAREN>  <ASSERT> t = <FIELDNAME> <IS> <UNIQUE>) | (<SEMICOLON> <CONSTRAINT> <ON> <LEFTPAREN> x = <CYPHERFIELD> <RIGHTPAREN>  <ASSERT> t = <FIELDNAME> <IS> <UNIQUE>))


{data.add("Node", x.image);}
{data.add("Tuple", t.image);}
{data.add("type", "UNIQUE");}


{jObject.add("CONSTRAINT", data.build());}/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {return jObject;}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

JsonObjectBuilder createEntryStatement(JsonObjectBuilder jObject) : {/*@bgen(jjtree) createEntryStatement */
                                                                     SimpleNode jjtn000 = new SimpleNode(JJTCREATEENTRYSTATEMENT);
                                                                     boolean jjtc000 = true;
                                                                     jjtree.openNodeScope(jjtn000);
/*@egen*/JsonObjectBuilder cypherNode = Json.createObjectBuilder(); JsonArrayBuilder cNode = Json.createArrayBuilder();  JsonArrayBuilder cEdge = Json.createArrayBuilder(); Token t = null;}
{/*@bgen(jjtree) createEntryStatement */
 try {
/*@egen*/
 (cypherNode = cypherNode(cypherNode) {cNode.add(cypherNode.build());} )(t = CypherEdge() {cEdge.add(t.image ); } cypherNode = cypherNode(cypherNode) {cNode.add(cypherNode.build());})?


 {jObject.add("node", cNode.build());}
 {jObject.add("edge", cEdge.build());}/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {return jObject;}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}


JsonObjectBuilder MatchStatement(JsonObjectBuilder jObject) : {/*@bgen(jjtree) MatchStatement */
                                                               SimpleNode jjtn000 = new SimpleNode(JJTMATCHSTATEMENT);
                                                               boolean jjtc000 = true;
                                                               jjtree.openNodeScope(jjtn000);
/*@egen*/JsonObjectBuilder mergeStmt = Json.createObjectBuilder(); Token t;}
{/*@bgen(jjtree) MatchStatement */
 try {
/*@egen*/
 <MATCH> (<LEFTPAREN> (LOOKAHEAD(1) t = <CYPHERFIELD> |t = <ALPHANUM>)<RIGHTPAREN>  mergeStmt = MergeStatement(mergeStmt))

 //(<LEFTPAREN> (LOOKAHEAD(1) t = <CYPHERFIELD> |t = <ALPHANUM>)<RIGHTPAREN><LT><MINUS><LEFTBRACKET><CYPHERFIELD><RIGHTBRACKET><MINUS><LEFTPAREN> (LOOKAHEAD(1) t = <CYPHERFIELD> |t = <ALPHANUM>)<RIGHTPAREN><MINUS><LEFTBRACKET><CYPHERFIELD><RIGHTBRACKET><MINUS><GT><LEFTPAREN> (LOOKAHEAD(1) t = <CYPHERFIELD> |t = <ALPHANUM>) <RIGHTPAREN> )


 {jObject = handleMatchStatement(jObject, t.image, mergeStmt );}/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/

 {return jObject;}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}

JsonObjectBuilder MergeStatement(JsonObjectBuilder mergeStmt) : {/*@bgen(jjtree) MergeStatement */
                                                                 SimpleNode jjtn000 = new SimpleNode(JJTMERGESTATEMENT);
                                                                 boolean jjtc000 = true;
                                                                 jjtree.openNodeScope(jjtn000);
/*@egen*/JsonObjectBuilder createStmt = Json.createObjectBuilder();}
{/*@bgen(jjtree) MergeStatement */
try {
/*@egen*/

<MERGE> createStmt = createEntryStatement(createStmt)
{mergeStmt.add("MERGE", createStmt.build());}/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{return mergeStmt;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}



JsonObjectBuilder cypherNode(JsonObjectBuilder jObject) : {/*@bgen(jjtree) cypherNode */
                                                           SimpleNode jjtn000 = new SimpleNode(JJTCYPHERNODE);
                                                           boolean jjtc000 = true;
                                                           jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; JsonObjectBuilder jb = Json.createObjectBuilder();}
{/*@bgen(jjtree) cypherNode */
try {
/*@egen*/

(<LEFTPAREN> (LOOKAHEAD(1) t = <CYPHERFIELD> |t = <ALPHANUM>) (<LEFTCURL>  (jb = nodeProperty(jb))? <RIGHTCURL> )? <RIGHTPAREN> {jObject = handleCypherNode(jObject, jb, t.image );} )(<COMMA> <LEFTPAREN> (LOOKAHEAD(1) t = <CYPHERFIELD>|t = <ALPHANUM>) (<LEFTCURL>jb = nodeProperty(jb)<RIGHTCURL> {jObject = handleCypherNode(jObject, jb, t.image );})? <RIGHTPAREN>)?/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/



{return jObject; }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

Token  CypherEdge() : {/*@bgen(jjtree) CypherEdge */
                       SimpleNode jjtn000 = new SimpleNode(JJTCYPHEREDGE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) CypherEdge */
 try {
/*@egen*/

 <MINUS><LEFTBRACKET><COLON> t = <ALPHANUM><RIGHTBRACKET><MINUS><GT>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{return t;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

 JsonObjectBuilder nodeProperty(JsonObjectBuilder jb) : {/*@bgen(jjtree) nodeProperty */
                                                          SimpleNode jjtn000 = new SimpleNode(JJTNODEPROPERTY);
                                                          boolean jjtc000 = true;
                                                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token x; Token t;  boolean unnestFlag = false; JsonObjectBuilder tempJB = Json.createObjectBuilder();}

{/*@bgen(jjtree) nodeProperty */
try {
/*@egen*/

( x = <ALPHANUM> <COLON> (LOOKAHEAD(1)( t = <FIELDNAME>)|(<UNNEST> <LEFTPAREN> t = <FIELDNAME><RIGHTPAREN> {unnestFlag = true;}) ) {tempJB = handleNodeProperty( tempJB, x.image,  t.image, unnestFlag );} ) ( (<COMMA> x = <ALPHANUM> <COLON> ( LOOKAHEAD(1)(t = <FIELDNAME>)|(<UNNEST> <LEFTPAREN> t= <FIELDNAME><RIGHTPAREN> {unnestFlag = true;} ) ) {tempJB = handleNodeProperty( tempJB, x.image,  t.image, unnestFlag );})+)?


{jb.add(x.image, tempJB.build());}/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{return jb;}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

/*create (u:User {id: Collection.Tweet.User.id,
								name: Collection.Tweet.User.name})
						-[:created]->
					   (n:Tweet {id: Collection.Tweet.TweetID,
						  TweetDate:Collection.Tweet.TweetDate,
						  Text:Collection.Tweet.Text})

						  match (n:Tweet) merge (n)-[:hasHashTag]->(h:HashTag {tag: unnest(Collection.Tweet.Entities.HashTags)}
                          				match (n:Tweet), (u:User) merge (n)-[:mentions]->(u:User {uname: unnest(Collection.Tweet.Entities.user_mentions.id)}

*/





